{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Shape = exports.shapes = void 0;\n\nconst Global_1 = require(\"./Global\");\n\nconst Util_1 = require(\"./Util\");\n\nconst Factory_1 = require(\"./Factory\");\n\nconst Node_1 = require(\"./Node\");\n\nconst Validators_1 = require(\"./Validators\");\n\nconst Global_2 = require(\"./Global\");\n\nconst PointerEvents = require(\"./PointerEvents\");\n\nvar HAS_SHADOW = 'hasShadow';\nvar SHADOW_RGBA = 'shadowRGBA';\nvar patternImage = 'patternImage';\nvar linearGradient = 'linearGradient';\nvar radialGradient = 'radialGradient';\nlet dummyContext;\n\nfunction getDummyContext() {\n  if (dummyContext) {\n    return dummyContext;\n  }\n\n  dummyContext = Util_1.Util.createCanvasElement().getContext('2d');\n  return dummyContext;\n}\n\nexports.shapes = {};\n\nfunction _fillFunc(context) {\n  const fillRule = this.attrs.fillRule;\n\n  if (fillRule) {\n    context.fill(fillRule);\n  } else {\n    context.fill();\n  }\n}\n\nfunction _strokeFunc(context) {\n  context.stroke();\n}\n\nfunction _fillFuncHit(context) {\n  const fillRule = this.attrs.fillRule;\n\n  if (fillRule) {\n    context.fill(fillRule);\n  } else {\n    context.fill();\n  }\n}\n\nfunction _strokeFuncHit(context) {\n  context.stroke();\n}\n\nfunction _clearHasShadowCache() {\n  this._clearCache(HAS_SHADOW);\n}\n\nfunction _clearGetShadowRGBACache() {\n  this._clearCache(SHADOW_RGBA);\n}\n\nfunction _clearFillPatternCache() {\n  this._clearCache(patternImage);\n}\n\nfunction _clearLinearGradientCache() {\n  this._clearCache(linearGradient);\n}\n\nfunction _clearRadialGradientCache() {\n  this._clearCache(radialGradient);\n}\n\nclass Shape extends Node_1.Node {\n  constructor(config) {\n    super(config);\n    let key;\n\n    while (true) {\n      key = Util_1.Util.getRandomColor();\n\n      if (key && !(key in exports.shapes)) {\n        break;\n      }\n    }\n\n    this.colorKey = key;\n    exports.shapes[key] = this;\n  }\n\n  getContext() {\n    Util_1.Util.warn('shape.getContext() method is deprecated. Please do not use it.');\n    return this.getLayer().getContext();\n  }\n\n  getCanvas() {\n    Util_1.Util.warn('shape.getCanvas() method is deprecated. Please do not use it.');\n    return this.getLayer().getCanvas();\n  }\n\n  getSceneFunc() {\n    return this.attrs.sceneFunc || this['_sceneFunc'];\n  }\n\n  getHitFunc() {\n    return this.attrs.hitFunc || this['_hitFunc'];\n  }\n\n  hasShadow() {\n    return this._getCache(HAS_SHADOW, this._hasShadow);\n  }\n\n  _hasShadow() {\n    return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY());\n  }\n\n  _getFillPattern() {\n    return this._getCache(patternImage, this.__getFillPattern);\n  }\n\n  __getFillPattern() {\n    if (this.fillPatternImage()) {\n      var ctx = getDummyContext();\n      const pattern = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || 'repeat');\n\n      if (pattern && pattern.setTransform) {\n        const tr = new Util_1.Transform();\n        tr.translate(this.fillPatternX(), this.fillPatternY());\n        tr.rotate(Global_1.Konva.getAngle(this.fillPatternRotation()));\n        tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY());\n        tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());\n        const m = tr.getMatrix();\n        const matrix = typeof DOMMatrix === 'undefined' ? {\n          a: m[0],\n          b: m[1],\n          c: m[2],\n          d: m[3],\n          e: m[4],\n          f: m[5]\n        } : new DOMMatrix(m);\n        pattern.setTransform(matrix);\n      }\n\n      return pattern;\n    }\n  }\n\n  _getLinearGradient() {\n    return this._getCache(linearGradient, this.__getLinearGradient);\n  }\n\n  __getLinearGradient() {\n    var colorStops = this.fillLinearGradientColorStops();\n\n    if (colorStops) {\n      var ctx = getDummyContext();\n      var start = this.fillLinearGradientStartPoint();\n      var end = this.fillLinearGradientEndPoint();\n      var grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\n\n      for (var n = 0; n < colorStops.length; n += 2) {\n        grd.addColorStop(colorStops[n], colorStops[n + 1]);\n      }\n\n      return grd;\n    }\n  }\n\n  _getRadialGradient() {\n    return this._getCache(radialGradient, this.__getRadialGradient);\n  }\n\n  __getRadialGradient() {\n    var colorStops = this.fillRadialGradientColorStops();\n\n    if (colorStops) {\n      var ctx = getDummyContext();\n      var start = this.fillRadialGradientStartPoint();\n      var end = this.fillRadialGradientEndPoint();\n      var grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());\n\n      for (var n = 0; n < colorStops.length; n += 2) {\n        grd.addColorStop(colorStops[n], colorStops[n + 1]);\n      }\n\n      return grd;\n    }\n  }\n\n  getShadowRGBA() {\n    return this._getCache(SHADOW_RGBA, this._getShadowRGBA);\n  }\n\n  _getShadowRGBA() {\n    if (!this.hasShadow()) {\n      return;\n    }\n\n    var rgba = Util_1.Util.colorToRGBA(this.shadowColor());\n\n    if (rgba) {\n      return 'rgba(' + rgba.r + ',' + rgba.g + ',' + rgba.b + ',' + rgba.a * (this.shadowOpacity() || 1) + ')';\n    }\n  }\n\n  hasFill() {\n    return this._calculate('hasFill', ['fillEnabled', 'fill', 'fillPatternImage', 'fillLinearGradientColorStops', 'fillRadialGradientColorStops'], () => {\n      return this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops());\n    });\n  }\n\n  hasStroke() {\n    return this._calculate('hasStroke', ['strokeEnabled', 'strokeWidth', 'stroke', 'strokeLinearGradientColorStops'], () => {\n      return this.strokeEnabled() && this.strokeWidth() && !!(this.stroke() || this.strokeLinearGradientColorStops());\n    });\n  }\n\n  hasHitStroke() {\n    const width = this.hitStrokeWidth();\n\n    if (width === 'auto') {\n      return this.hasStroke();\n    }\n\n    return this.strokeEnabled() && !!width;\n  }\n\n  intersects(point) {\n    var stage = this.getStage();\n\n    if (!stage) {\n      return false;\n    }\n\n    const bufferHitCanvas = stage.bufferHitCanvas;\n    bufferHitCanvas.getContext().clear();\n    this.drawHit(bufferHitCanvas, undefined, true);\n    const p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;\n    return p[3] > 0;\n  }\n\n  destroy() {\n    Node_1.Node.prototype.destroy.call(this);\n    delete exports.shapes[this.colorKey];\n    delete this.colorKey;\n    return this;\n  }\n\n  _useBufferCanvas(forceFill) {\n    var _a;\n\n    const perfectDrawEnabled = (_a = this.attrs.perfectDrawEnabled) !== null && _a !== void 0 ? _a : true;\n\n    if (!perfectDrawEnabled) {\n      return false;\n    }\n\n    const hasFill = forceFill || this.hasFill();\n    const hasStroke = this.hasStroke();\n    const isTransparent = this.getAbsoluteOpacity() !== 1;\n\n    if (hasFill && hasStroke && isTransparent) {\n      return true;\n    }\n\n    const hasShadow = this.hasShadow();\n    const strokeForShadow = this.shadowForStrokeEnabled();\n\n    if (hasFill && hasStroke && hasShadow && strokeForShadow) {\n      return true;\n    }\n\n    return false;\n  }\n\n  setStrokeHitEnabled(val) {\n    Util_1.Util.warn('strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead.');\n\n    if (val) {\n      this.hitStrokeWidth('auto');\n    } else {\n      this.hitStrokeWidth(0);\n    }\n  }\n\n  getStrokeHitEnabled() {\n    if (this.hitStrokeWidth() === 0) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  getSelfRect() {\n    var size = this.size();\n    return {\n      x: this._centroid ? -size.width / 2 : 0,\n      y: this._centroid ? -size.height / 2 : 0,\n      width: size.width,\n      height: size.height\n    };\n  }\n\n  getClientRect() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let hasCachedParent = false;\n    let parent = this.getParent();\n\n    while (parent) {\n      if (parent.isCached()) {\n        hasCachedParent = true;\n        break;\n      }\n\n      parent = parent.getParent();\n    }\n\n    const skipTransform = config.skipTransform;\n    const relativeTo = config.relativeTo || hasCachedParent && this.getStage() || undefined;\n    const fillRect = this.getSelfRect();\n    const applyStroke = !config.skipStroke && this.hasStroke();\n    const strokeWidth = applyStroke && this.strokeWidth() || 0;\n    const fillAndStrokeWidth = fillRect.width + strokeWidth;\n    const fillAndStrokeHeight = fillRect.height + strokeWidth;\n    const applyShadow = !config.skipShadow && this.hasShadow();\n    const shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;\n    const shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;\n    const preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);\n    const preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);\n    const blurRadius = applyShadow && this.shadowBlur() || 0;\n    const width = preWidth + blurRadius * 2;\n    const height = preHeight + blurRadius * 2;\n    const rect = {\n      width: width,\n      height: height,\n      x: -(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetX, 0) + fillRect.x,\n      y: -(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetY, 0) + fillRect.y\n    };\n\n    if (!skipTransform) {\n      return this._transformedRect(rect, relativeTo);\n    }\n\n    return rect;\n  }\n\n  drawScene(can, top, bufferCanvas) {\n    var layer = this.getLayer();\n\n    var canvas = can || layer.getCanvas(),\n        context = canvas.getContext(),\n        cachedCanvas = this._getCanvasCache(),\n        drawFunc = this.getSceneFunc(),\n        hasShadow = this.hasShadow(),\n        stage,\n        bufferContext;\n\n    var skipBuffer = canvas.isCache;\n    var cachingSelf = top === this;\n\n    if (!this.isVisible() && !cachingSelf) {\n      return this;\n    }\n\n    if (cachedCanvas) {\n      context.save();\n      var m = this.getAbsoluteTransform(top).getMatrix();\n      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n\n      this._drawCachedSceneCanvas(context);\n\n      context.restore();\n      return this;\n    }\n\n    if (!drawFunc) {\n      return this;\n    }\n\n    context.save();\n\n    if (this._useBufferCanvas() && !skipBuffer) {\n      stage = this.getStage();\n      const bc = bufferCanvas || stage.bufferCanvas;\n      bufferContext = bc.getContext();\n      bufferContext.clear();\n      bufferContext.save();\n\n      bufferContext._applyLineJoin(this);\n\n      var o = this.getAbsoluteTransform(top).getMatrix();\n      bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n      drawFunc.call(this, bufferContext, this);\n      bufferContext.restore();\n      var ratio = bc.pixelRatio;\n\n      if (hasShadow) {\n        context._applyShadow(this);\n      }\n\n      context._applyOpacity(this);\n\n      context._applyGlobalCompositeOperation(this);\n\n      context.drawImage(bc._canvas, 0, 0, bc.width / ratio, bc.height / ratio);\n    } else {\n      context._applyLineJoin(this);\n\n      if (!cachingSelf) {\n        var o = this.getAbsoluteTransform(top).getMatrix();\n        context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n\n        context._applyOpacity(this);\n\n        context._applyGlobalCompositeOperation(this);\n      }\n\n      if (hasShadow) {\n        context._applyShadow(this);\n      }\n\n      drawFunc.call(this, context, this);\n    }\n\n    context.restore();\n    return this;\n  }\n\n  drawHit(can, top) {\n    let skipDragCheck = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (!this.shouldDrawHit(top, skipDragCheck)) {\n      return this;\n    }\n\n    var layer = this.getLayer(),\n        canvas = can || layer.hitCanvas,\n        context = canvas && canvas.getContext(),\n        drawFunc = this.hitFunc() || this.sceneFunc(),\n        cachedCanvas = this._getCanvasCache(),\n        cachedHitCanvas = cachedCanvas && cachedCanvas.hit;\n\n    if (!this.colorKey) {\n      Util_1.Util.warn('Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()');\n    }\n\n    if (cachedHitCanvas) {\n      context.save();\n      var m = this.getAbsoluteTransform(top).getMatrix();\n      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n\n      this._drawCachedHitCanvas(context);\n\n      context.restore();\n      return this;\n    }\n\n    if (!drawFunc) {\n      return this;\n    }\n\n    context.save();\n\n    context._applyLineJoin(this);\n\n    const selfCache = this === top;\n\n    if (!selfCache) {\n      var o = this.getAbsoluteTransform(top).getMatrix();\n      context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n    }\n\n    drawFunc.call(this, context, this);\n    context.restore();\n    return this;\n  }\n\n  drawHitFromCache() {\n    let alphaThreshold = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    var cachedCanvas = this._getCanvasCache(),\n        sceneCanvas = this._getCachedSceneCanvas(),\n        hitCanvas = cachedCanvas.hit,\n        hitContext = hitCanvas.getContext(),\n        hitWidth = hitCanvas.getWidth(),\n        hitHeight = hitCanvas.getHeight(),\n        hitImageData,\n        hitData,\n        len,\n        rgbColorKey,\n        i,\n        alpha;\n\n    hitContext.clear();\n    hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);\n\n    try {\n      hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);\n      hitData = hitImageData.data;\n      len = hitData.length;\n      rgbColorKey = Util_1.Util._hexToRgb(this.colorKey);\n\n      for (i = 0; i < len; i += 4) {\n        alpha = hitData[i + 3];\n\n        if (alpha > alphaThreshold) {\n          hitData[i] = rgbColorKey.r;\n          hitData[i + 1] = rgbColorKey.g;\n          hitData[i + 2] = rgbColorKey.b;\n          hitData[i + 3] = 255;\n        } else {\n          hitData[i + 3] = 0;\n        }\n      }\n\n      hitContext.putImageData(hitImageData, 0, 0);\n    } catch (e) {\n      Util_1.Util.error('Unable to draw hit graph from cached scene canvas. ' + e.message);\n    }\n\n    return this;\n  }\n\n  hasPointerCapture(pointerId) {\n    return PointerEvents.hasPointerCapture(pointerId, this);\n  }\n\n  setPointerCapture(pointerId) {\n    PointerEvents.setPointerCapture(pointerId, this);\n  }\n\n  releaseCapture(pointerId) {\n    PointerEvents.releaseCapture(pointerId, this);\n  }\n\n}\n\nexports.Shape = Shape;\nShape.prototype._fillFunc = _fillFunc;\nShape.prototype._strokeFunc = _strokeFunc;\nShape.prototype._fillFuncHit = _fillFuncHit;\nShape.prototype._strokeFuncHit = _strokeFuncHit;\nShape.prototype._centroid = false;\nShape.prototype.nodeType = 'Shape';\n(0, Global_2._registerNode)(Shape);\nShape.prototype.eventListeners = {};\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearHasShadowCache);\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearGetShadowRGBACache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva', _clearFillPatternCache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva', _clearLinearGradientCache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva', _clearRadialGradientCache);\nFactory_1.Factory.addGetterSetter(Shape, 'stroke', undefined, (0, Validators_1.getStringOrGradientValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'strokeWidth', 2, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'fillAfterStrokeEnabled', false);\nFactory_1.Factory.addGetterSetter(Shape, 'hitStrokeWidth', 'auto', (0, Validators_1.getNumberOrAutoValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'strokeHitEnabled', true, (0, Validators_1.getBooleanValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'perfectDrawEnabled', true, (0, Validators_1.getBooleanValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'shadowForStrokeEnabled', true, (0, Validators_1.getBooleanValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'lineJoin');\nFactory_1.Factory.addGetterSetter(Shape, 'lineCap');\nFactory_1.Factory.addGetterSetter(Shape, 'sceneFunc');\nFactory_1.Factory.addGetterSetter(Shape, 'hitFunc');\nFactory_1.Factory.addGetterSetter(Shape, 'dash');\nFactory_1.Factory.addGetterSetter(Shape, 'dashOffset', 0, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'shadowColor', undefined, (0, Validators_1.getStringValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'shadowBlur', 0, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'shadowOpacity', 1, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addComponentsGetterSetter(Shape, 'shadowOffset', ['x', 'y']);\nFactory_1.Factory.addGetterSetter(Shape, 'shadowOffsetX', 0, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'shadowOffsetY', 0, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'fillPatternImage');\nFactory_1.Factory.addGetterSetter(Shape, 'fill', undefined, (0, Validators_1.getStringOrGradientValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'fillPatternX', 0, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'fillPatternY', 0, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientColorStops');\nFactory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientColorStops');\nFactory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientStartRadius', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientEndRadius', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientColorStops');\nFactory_1.Factory.addGetterSetter(Shape, 'fillPatternRepeat', 'repeat');\nFactory_1.Factory.addGetterSetter(Shape, 'fillEnabled', true);\nFactory_1.Factory.addGetterSetter(Shape, 'strokeEnabled', true);\nFactory_1.Factory.addGetterSetter(Shape, 'shadowEnabled', true);\nFactory_1.Factory.addGetterSetter(Shape, 'dashEnabled', true);\nFactory_1.Factory.addGetterSetter(Shape, 'strokeScaleEnabled', true);\nFactory_1.Factory.addGetterSetter(Shape, 'fillPriority', 'color');\nFactory_1.Factory.addComponentsGetterSetter(Shape, 'fillPatternOffset', ['x', 'y']);\nFactory_1.Factory.addGetterSetter(Shape, 'fillPatternOffsetX', 0, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'fillPatternOffsetY', 0, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addComponentsGetterSetter(Shape, 'fillPatternScale', ['x', 'y']);\nFactory_1.Factory.addGetterSetter(Shape, 'fillPatternScaleX', 1, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'fillPatternScaleY', 1, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addComponentsGetterSetter(Shape, 'fillLinearGradientStartPoint', ['x', 'y']);\nFactory_1.Factory.addComponentsGetterSetter(Shape, 'strokeLinearGradientStartPoint', ['x', 'y']);\nFactory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientStartPointX', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientStartPointX', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientStartPointY', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientStartPointY', 0);\nFactory_1.Factory.addComponentsGetterSetter(Shape, 'fillLinearGradientEndPoint', ['x', 'y']);\nFactory_1.Factory.addComponentsGetterSetter(Shape, 'strokeLinearGradientEndPoint', ['x', 'y']);\nFactory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientEndPointX', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientEndPointX', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientEndPointY', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientEndPointY', 0);\nFactory_1.Factory.addComponentsGetterSetter(Shape, 'fillRadialGradientStartPoint', ['x', 'y']);\nFactory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientStartPointX', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientStartPointY', 0);\nFactory_1.Factory.addComponentsGetterSetter(Shape, 'fillRadialGradientEndPoint', ['x', 'y']);\nFactory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientEndPointX', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientEndPointY', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'fillPatternRotation', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'fillRule', undefined, (0, Validators_1.getStringValidator)());\nFactory_1.Factory.backCompat(Shape, {\n  dashArray: 'dash',\n  getDashArray: 'getDash',\n  setDashArray: 'getDash',\n  drawFunc: 'sceneFunc',\n  getDrawFunc: 'getSceneFunc',\n  setDrawFunc: 'setSceneFunc',\n  drawHitFunc: 'hitFunc',\n  getDrawHitFunc: 'getHitFunc',\n  setDrawHitFunc: 'setHitFunc'\n});","map":{"version":3,"names":["Object","defineProperty","exports","value","Shape","shapes","Global_1","require","Util_1","Factory_1","Node_1","Validators_1","Global_2","PointerEvents","HAS_SHADOW","SHADOW_RGBA","patternImage","linearGradient","radialGradient","dummyContext","getDummyContext","Util","createCanvasElement","getContext","_fillFunc","context","fillRule","attrs","fill","_strokeFunc","stroke","_fillFuncHit","_strokeFuncHit","_clearHasShadowCache","_clearCache","_clearGetShadowRGBACache","_clearFillPatternCache","_clearLinearGradientCache","_clearRadialGradientCache","Node","constructor","config","key","getRandomColor","colorKey","warn","getLayer","getCanvas","getSceneFunc","sceneFunc","getHitFunc","hitFunc","hasShadow","_getCache","_hasShadow","shadowEnabled","shadowOpacity","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","_getFillPattern","__getFillPattern","fillPatternImage","ctx","pattern","createPattern","fillPatternRepeat","setTransform","tr","Transform","translate","fillPatternX","fillPatternY","rotate","Konva","getAngle","fillPatternRotation","scale","fillPatternScaleX","fillPatternScaleY","fillPatternOffsetX","fillPatternOffsetY","m","getMatrix","matrix","DOMMatrix","a","b","c","d","e","f","_getLinearGradient","__getLinearGradient","colorStops","fillLinearGradientColorStops","start","fillLinearGradientStartPoint","end","fillLinearGradientEndPoint","grd","createLinearGradient","x","y","n","length","addColorStop","_getRadialGradient","__getRadialGradient","fillRadialGradientColorStops","fillRadialGradientStartPoint","fillRadialGradientEndPoint","createRadialGradient","fillRadialGradientStartRadius","fillRadialGradientEndRadius","getShadowRGBA","_getShadowRGBA","rgba","colorToRGBA","r","g","hasFill","_calculate","fillEnabled","hasStroke","strokeEnabled","strokeWidth","strokeLinearGradientColorStops","hasHitStroke","width","hitStrokeWidth","intersects","point","stage","getStage","bufferHitCanvas","clear","drawHit","undefined","p","getImageData","Math","round","data","destroy","prototype","call","_useBufferCanvas","forceFill","_a","perfectDrawEnabled","isTransparent","getAbsoluteOpacity","strokeForShadow","shadowForStrokeEnabled","setStrokeHitEnabled","val","getStrokeHitEnabled","getSelfRect","size","_centroid","height","getClientRect","hasCachedParent","parent","getParent","isCached","skipTransform","relativeTo","fillRect","applyStroke","skipStroke","fillAndStrokeWidth","fillAndStrokeHeight","applyShadow","skipShadow","preWidth","abs","preHeight","blurRadius","rect","min","_transformedRect","drawScene","can","top","bufferCanvas","layer","canvas","cachedCanvas","_getCanvasCache","drawFunc","bufferContext","skipBuffer","isCache","cachingSelf","isVisible","save","getAbsoluteTransform","transform","_drawCachedSceneCanvas","restore","bc","_applyLineJoin","o","ratio","pixelRatio","_applyShadow","_applyOpacity","_applyGlobalCompositeOperation","drawImage","_canvas","skipDragCheck","shouldDrawHit","hitCanvas","cachedHitCanvas","hit","_drawCachedHitCanvas","selfCache","drawHitFromCache","alphaThreshold","sceneCanvas","_getCachedSceneCanvas","hitContext","hitWidth","getWidth","hitHeight","getHeight","hitImageData","hitData","len","rgbColorKey","i","alpha","_hexToRgb","putImageData","error","message","hasPointerCapture","pointerId","setPointerCapture","releaseCapture","nodeType","_registerNode","eventListeners","on","Factory","addGetterSetter","getStringOrGradientValidator","getNumberValidator","getNumberOrAutoValidator","getBooleanValidator","getStringValidator","addComponentsGetterSetter","backCompat","dashArray","getDashArray","setDashArray","getDrawFunc","setDrawFunc","drawHitFunc","getDrawHitFunc","setDrawHitFunc"],"sources":["D:/screenshort-extension/image-editor-react/node_modules/konva/lib/Shape.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Shape = exports.shapes = void 0;\nconst Global_1 = require(\"./Global\");\nconst Util_1 = require(\"./Util\");\nconst Factory_1 = require(\"./Factory\");\nconst Node_1 = require(\"./Node\");\nconst Validators_1 = require(\"./Validators\");\nconst Global_2 = require(\"./Global\");\nconst PointerEvents = require(\"./PointerEvents\");\nvar HAS_SHADOW = 'hasShadow';\nvar SHADOW_RGBA = 'shadowRGBA';\nvar patternImage = 'patternImage';\nvar linearGradient = 'linearGradient';\nvar radialGradient = 'radialGradient';\nlet dummyContext;\nfunction getDummyContext() {\n    if (dummyContext) {\n        return dummyContext;\n    }\n    dummyContext = Util_1.Util.createCanvasElement().getContext('2d');\n    return dummyContext;\n}\nexports.shapes = {};\nfunction _fillFunc(context) {\n    const fillRule = this.attrs.fillRule;\n    if (fillRule) {\n        context.fill(fillRule);\n    }\n    else {\n        context.fill();\n    }\n}\nfunction _strokeFunc(context) {\n    context.stroke();\n}\nfunction _fillFuncHit(context) {\n    const fillRule = this.attrs.fillRule;\n    if (fillRule) {\n        context.fill(fillRule);\n    }\n    else {\n        context.fill();\n    }\n}\nfunction _strokeFuncHit(context) {\n    context.stroke();\n}\nfunction _clearHasShadowCache() {\n    this._clearCache(HAS_SHADOW);\n}\nfunction _clearGetShadowRGBACache() {\n    this._clearCache(SHADOW_RGBA);\n}\nfunction _clearFillPatternCache() {\n    this._clearCache(patternImage);\n}\nfunction _clearLinearGradientCache() {\n    this._clearCache(linearGradient);\n}\nfunction _clearRadialGradientCache() {\n    this._clearCache(radialGradient);\n}\nclass Shape extends Node_1.Node {\n    constructor(config) {\n        super(config);\n        let key;\n        while (true) {\n            key = Util_1.Util.getRandomColor();\n            if (key && !(key in exports.shapes)) {\n                break;\n            }\n        }\n        this.colorKey = key;\n        exports.shapes[key] = this;\n    }\n    getContext() {\n        Util_1.Util.warn('shape.getContext() method is deprecated. Please do not use it.');\n        return this.getLayer().getContext();\n    }\n    getCanvas() {\n        Util_1.Util.warn('shape.getCanvas() method is deprecated. Please do not use it.');\n        return this.getLayer().getCanvas();\n    }\n    getSceneFunc() {\n        return this.attrs.sceneFunc || this['_sceneFunc'];\n    }\n    getHitFunc() {\n        return this.attrs.hitFunc || this['_hitFunc'];\n    }\n    hasShadow() {\n        return this._getCache(HAS_SHADOW, this._hasShadow);\n    }\n    _hasShadow() {\n        return (this.shadowEnabled() &&\n            this.shadowOpacity() !== 0 &&\n            !!(this.shadowColor() ||\n                this.shadowBlur() ||\n                this.shadowOffsetX() ||\n                this.shadowOffsetY()));\n    }\n    _getFillPattern() {\n        return this._getCache(patternImage, this.__getFillPattern);\n    }\n    __getFillPattern() {\n        if (this.fillPatternImage()) {\n            var ctx = getDummyContext();\n            const pattern = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || 'repeat');\n            if (pattern && pattern.setTransform) {\n                const tr = new Util_1.Transform();\n                tr.translate(this.fillPatternX(), this.fillPatternY());\n                tr.rotate(Global_1.Konva.getAngle(this.fillPatternRotation()));\n                tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY());\n                tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());\n                const m = tr.getMatrix();\n                const matrix = typeof DOMMatrix === 'undefined'\n                    ? {\n                        a: m[0],\n                        b: m[1],\n                        c: m[2],\n                        d: m[3],\n                        e: m[4],\n                        f: m[5],\n                    }\n                    : new DOMMatrix(m);\n                pattern.setTransform(matrix);\n            }\n            return pattern;\n        }\n    }\n    _getLinearGradient() {\n        return this._getCache(linearGradient, this.__getLinearGradient);\n    }\n    __getLinearGradient() {\n        var colorStops = this.fillLinearGradientColorStops();\n        if (colorStops) {\n            var ctx = getDummyContext();\n            var start = this.fillLinearGradientStartPoint();\n            var end = this.fillLinearGradientEndPoint();\n            var grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\n            for (var n = 0; n < colorStops.length; n += 2) {\n                grd.addColorStop(colorStops[n], colorStops[n + 1]);\n            }\n            return grd;\n        }\n    }\n    _getRadialGradient() {\n        return this._getCache(radialGradient, this.__getRadialGradient);\n    }\n    __getRadialGradient() {\n        var colorStops = this.fillRadialGradientColorStops();\n        if (colorStops) {\n            var ctx = getDummyContext();\n            var start = this.fillRadialGradientStartPoint();\n            var end = this.fillRadialGradientEndPoint();\n            var grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());\n            for (var n = 0; n < colorStops.length; n += 2) {\n                grd.addColorStop(colorStops[n], colorStops[n + 1]);\n            }\n            return grd;\n        }\n    }\n    getShadowRGBA() {\n        return this._getCache(SHADOW_RGBA, this._getShadowRGBA);\n    }\n    _getShadowRGBA() {\n        if (!this.hasShadow()) {\n            return;\n        }\n        var rgba = Util_1.Util.colorToRGBA(this.shadowColor());\n        if (rgba) {\n            return ('rgba(' +\n                rgba.r +\n                ',' +\n                rgba.g +\n                ',' +\n                rgba.b +\n                ',' +\n                rgba.a * (this.shadowOpacity() || 1) +\n                ')');\n        }\n    }\n    hasFill() {\n        return this._calculate('hasFill', [\n            'fillEnabled',\n            'fill',\n            'fillPatternImage',\n            'fillLinearGradientColorStops',\n            'fillRadialGradientColorStops',\n        ], () => {\n            return (this.fillEnabled() &&\n                !!(this.fill() ||\n                    this.fillPatternImage() ||\n                    this.fillLinearGradientColorStops() ||\n                    this.fillRadialGradientColorStops()));\n        });\n    }\n    hasStroke() {\n        return this._calculate('hasStroke', [\n            'strokeEnabled',\n            'strokeWidth',\n            'stroke',\n            'strokeLinearGradientColorStops',\n        ], () => {\n            return (this.strokeEnabled() &&\n                this.strokeWidth() &&\n                !!(this.stroke() || this.strokeLinearGradientColorStops()));\n        });\n    }\n    hasHitStroke() {\n        const width = this.hitStrokeWidth();\n        if (width === 'auto') {\n            return this.hasStroke();\n        }\n        return this.strokeEnabled() && !!width;\n    }\n    intersects(point) {\n        var stage = this.getStage();\n        if (!stage) {\n            return false;\n        }\n        const bufferHitCanvas = stage.bufferHitCanvas;\n        bufferHitCanvas.getContext().clear();\n        this.drawHit(bufferHitCanvas, undefined, true);\n        const p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;\n        return p[3] > 0;\n    }\n    destroy() {\n        Node_1.Node.prototype.destroy.call(this);\n        delete exports.shapes[this.colorKey];\n        delete this.colorKey;\n        return this;\n    }\n    _useBufferCanvas(forceFill) {\n        var _a;\n        const perfectDrawEnabled = (_a = this.attrs.perfectDrawEnabled) !== null && _a !== void 0 ? _a : true;\n        if (!perfectDrawEnabled) {\n            return false;\n        }\n        const hasFill = forceFill || this.hasFill();\n        const hasStroke = this.hasStroke();\n        const isTransparent = this.getAbsoluteOpacity() !== 1;\n        if (hasFill && hasStroke && isTransparent) {\n            return true;\n        }\n        const hasShadow = this.hasShadow();\n        const strokeForShadow = this.shadowForStrokeEnabled();\n        if (hasFill && hasStroke && hasShadow && strokeForShadow) {\n            return true;\n        }\n        return false;\n    }\n    setStrokeHitEnabled(val) {\n        Util_1.Util.warn('strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead.');\n        if (val) {\n            this.hitStrokeWidth('auto');\n        }\n        else {\n            this.hitStrokeWidth(0);\n        }\n    }\n    getStrokeHitEnabled() {\n        if (this.hitStrokeWidth() === 0) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    getSelfRect() {\n        var size = this.size();\n        return {\n            x: this._centroid ? -size.width / 2 : 0,\n            y: this._centroid ? -size.height / 2 : 0,\n            width: size.width,\n            height: size.height,\n        };\n    }\n    getClientRect(config = {}) {\n        let hasCachedParent = false;\n        let parent = this.getParent();\n        while (parent) {\n            if (parent.isCached()) {\n                hasCachedParent = true;\n                break;\n            }\n            parent = parent.getParent();\n        }\n        const skipTransform = config.skipTransform;\n        const relativeTo = config.relativeTo || (hasCachedParent && this.getStage()) || undefined;\n        const fillRect = this.getSelfRect();\n        const applyStroke = !config.skipStroke && this.hasStroke();\n        const strokeWidth = (applyStroke && this.strokeWidth()) || 0;\n        const fillAndStrokeWidth = fillRect.width + strokeWidth;\n        const fillAndStrokeHeight = fillRect.height + strokeWidth;\n        const applyShadow = !config.skipShadow && this.hasShadow();\n        const shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;\n        const shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;\n        const preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);\n        const preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);\n        const blurRadius = (applyShadow && this.shadowBlur()) || 0;\n        const width = preWidth + blurRadius * 2;\n        const height = preHeight + blurRadius * 2;\n        const rect = {\n            width: width,\n            height: height,\n            x: -(strokeWidth / 2 + blurRadius) +\n                Math.min(shadowOffsetX, 0) +\n                fillRect.x,\n            y: -(strokeWidth / 2 + blurRadius) +\n                Math.min(shadowOffsetY, 0) +\n                fillRect.y,\n        };\n        if (!skipTransform) {\n            return this._transformedRect(rect, relativeTo);\n        }\n        return rect;\n    }\n    drawScene(can, top, bufferCanvas) {\n        var layer = this.getLayer();\n        var canvas = can || layer.getCanvas(), context = canvas.getContext(), cachedCanvas = this._getCanvasCache(), drawFunc = this.getSceneFunc(), hasShadow = this.hasShadow(), stage, bufferContext;\n        var skipBuffer = canvas.isCache;\n        var cachingSelf = top === this;\n        if (!this.isVisible() && !cachingSelf) {\n            return this;\n        }\n        if (cachedCanvas) {\n            context.save();\n            var m = this.getAbsoluteTransform(top).getMatrix();\n            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n            this._drawCachedSceneCanvas(context);\n            context.restore();\n            return this;\n        }\n        if (!drawFunc) {\n            return this;\n        }\n        context.save();\n        if (this._useBufferCanvas() && !skipBuffer) {\n            stage = this.getStage();\n            const bc = bufferCanvas || stage.bufferCanvas;\n            bufferContext = bc.getContext();\n            bufferContext.clear();\n            bufferContext.save();\n            bufferContext._applyLineJoin(this);\n            var o = this.getAbsoluteTransform(top).getMatrix();\n            bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n            drawFunc.call(this, bufferContext, this);\n            bufferContext.restore();\n            var ratio = bc.pixelRatio;\n            if (hasShadow) {\n                context._applyShadow(this);\n            }\n            context._applyOpacity(this);\n            context._applyGlobalCompositeOperation(this);\n            context.drawImage(bc._canvas, 0, 0, bc.width / ratio, bc.height / ratio);\n        }\n        else {\n            context._applyLineJoin(this);\n            if (!cachingSelf) {\n                var o = this.getAbsoluteTransform(top).getMatrix();\n                context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n                context._applyOpacity(this);\n                context._applyGlobalCompositeOperation(this);\n            }\n            if (hasShadow) {\n                context._applyShadow(this);\n            }\n            drawFunc.call(this, context, this);\n        }\n        context.restore();\n        return this;\n    }\n    drawHit(can, top, skipDragCheck = false) {\n        if (!this.shouldDrawHit(top, skipDragCheck)) {\n            return this;\n        }\n        var layer = this.getLayer(), canvas = can || layer.hitCanvas, context = canvas && canvas.getContext(), drawFunc = this.hitFunc() || this.sceneFunc(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;\n        if (!this.colorKey) {\n            Util_1.Util.warn('Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()');\n        }\n        if (cachedHitCanvas) {\n            context.save();\n            var m = this.getAbsoluteTransform(top).getMatrix();\n            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n            this._drawCachedHitCanvas(context);\n            context.restore();\n            return this;\n        }\n        if (!drawFunc) {\n            return this;\n        }\n        context.save();\n        context._applyLineJoin(this);\n        const selfCache = this === top;\n        if (!selfCache) {\n            var o = this.getAbsoluteTransform(top).getMatrix();\n            context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n        }\n        drawFunc.call(this, context, this);\n        context.restore();\n        return this;\n    }\n    drawHitFromCache(alphaThreshold = 0) {\n        var cachedCanvas = this._getCanvasCache(), sceneCanvas = this._getCachedSceneCanvas(), hitCanvas = cachedCanvas.hit, hitContext = hitCanvas.getContext(), hitWidth = hitCanvas.getWidth(), hitHeight = hitCanvas.getHeight(), hitImageData, hitData, len, rgbColorKey, i, alpha;\n        hitContext.clear();\n        hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);\n        try {\n            hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);\n            hitData = hitImageData.data;\n            len = hitData.length;\n            rgbColorKey = Util_1.Util._hexToRgb(this.colorKey);\n            for (i = 0; i < len; i += 4) {\n                alpha = hitData[i + 3];\n                if (alpha > alphaThreshold) {\n                    hitData[i] = rgbColorKey.r;\n                    hitData[i + 1] = rgbColorKey.g;\n                    hitData[i + 2] = rgbColorKey.b;\n                    hitData[i + 3] = 255;\n                }\n                else {\n                    hitData[i + 3] = 0;\n                }\n            }\n            hitContext.putImageData(hitImageData, 0, 0);\n        }\n        catch (e) {\n            Util_1.Util.error('Unable to draw hit graph from cached scene canvas. ' + e.message);\n        }\n        return this;\n    }\n    hasPointerCapture(pointerId) {\n        return PointerEvents.hasPointerCapture(pointerId, this);\n    }\n    setPointerCapture(pointerId) {\n        PointerEvents.setPointerCapture(pointerId, this);\n    }\n    releaseCapture(pointerId) {\n        PointerEvents.releaseCapture(pointerId, this);\n    }\n}\nexports.Shape = Shape;\nShape.prototype._fillFunc = _fillFunc;\nShape.prototype._strokeFunc = _strokeFunc;\nShape.prototype._fillFuncHit = _fillFuncHit;\nShape.prototype._strokeFuncHit = _strokeFuncHit;\nShape.prototype._centroid = false;\nShape.prototype.nodeType = 'Shape';\n(0, Global_2._registerNode)(Shape);\nShape.prototype.eventListeners = {};\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearHasShadowCache);\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearGetShadowRGBACache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva', _clearFillPatternCache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva', _clearLinearGradientCache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva', _clearRadialGradientCache);\nFactory_1.Factory.addGetterSetter(Shape, 'stroke', undefined, (0, Validators_1.getStringOrGradientValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'strokeWidth', 2, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'fillAfterStrokeEnabled', false);\nFactory_1.Factory.addGetterSetter(Shape, 'hitStrokeWidth', 'auto', (0, Validators_1.getNumberOrAutoValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'strokeHitEnabled', true, (0, Validators_1.getBooleanValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'perfectDrawEnabled', true, (0, Validators_1.getBooleanValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'shadowForStrokeEnabled', true, (0, Validators_1.getBooleanValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'lineJoin');\nFactory_1.Factory.addGetterSetter(Shape, 'lineCap');\nFactory_1.Factory.addGetterSetter(Shape, 'sceneFunc');\nFactory_1.Factory.addGetterSetter(Shape, 'hitFunc');\nFactory_1.Factory.addGetterSetter(Shape, 'dash');\nFactory_1.Factory.addGetterSetter(Shape, 'dashOffset', 0, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'shadowColor', undefined, (0, Validators_1.getStringValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'shadowBlur', 0, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'shadowOpacity', 1, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addComponentsGetterSetter(Shape, 'shadowOffset', ['x', 'y']);\nFactory_1.Factory.addGetterSetter(Shape, 'shadowOffsetX', 0, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'shadowOffsetY', 0, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'fillPatternImage');\nFactory_1.Factory.addGetterSetter(Shape, 'fill', undefined, (0, Validators_1.getStringOrGradientValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'fillPatternX', 0, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'fillPatternY', 0, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientColorStops');\nFactory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientColorStops');\nFactory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientStartRadius', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientEndRadius', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientColorStops');\nFactory_1.Factory.addGetterSetter(Shape, 'fillPatternRepeat', 'repeat');\nFactory_1.Factory.addGetterSetter(Shape, 'fillEnabled', true);\nFactory_1.Factory.addGetterSetter(Shape, 'strokeEnabled', true);\nFactory_1.Factory.addGetterSetter(Shape, 'shadowEnabled', true);\nFactory_1.Factory.addGetterSetter(Shape, 'dashEnabled', true);\nFactory_1.Factory.addGetterSetter(Shape, 'strokeScaleEnabled', true);\nFactory_1.Factory.addGetterSetter(Shape, 'fillPriority', 'color');\nFactory_1.Factory.addComponentsGetterSetter(Shape, 'fillPatternOffset', ['x', 'y']);\nFactory_1.Factory.addGetterSetter(Shape, 'fillPatternOffsetX', 0, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'fillPatternOffsetY', 0, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addComponentsGetterSetter(Shape, 'fillPatternScale', ['x', 'y']);\nFactory_1.Factory.addGetterSetter(Shape, 'fillPatternScaleX', 1, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addGetterSetter(Shape, 'fillPatternScaleY', 1, (0, Validators_1.getNumberValidator)());\nFactory_1.Factory.addComponentsGetterSetter(Shape, 'fillLinearGradientStartPoint', [\n    'x',\n    'y',\n]);\nFactory_1.Factory.addComponentsGetterSetter(Shape, 'strokeLinearGradientStartPoint', [\n    'x',\n    'y',\n]);\nFactory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientStartPointX', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientStartPointX', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientStartPointY', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientStartPointY', 0);\nFactory_1.Factory.addComponentsGetterSetter(Shape, 'fillLinearGradientEndPoint', [\n    'x',\n    'y',\n]);\nFactory_1.Factory.addComponentsGetterSetter(Shape, 'strokeLinearGradientEndPoint', [\n    'x',\n    'y',\n]);\nFactory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientEndPointX', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientEndPointX', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientEndPointY', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientEndPointY', 0);\nFactory_1.Factory.addComponentsGetterSetter(Shape, 'fillRadialGradientStartPoint', [\n    'x',\n    'y',\n]);\nFactory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientStartPointX', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientStartPointY', 0);\nFactory_1.Factory.addComponentsGetterSetter(Shape, 'fillRadialGradientEndPoint', [\n    'x',\n    'y',\n]);\nFactory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientEndPointX', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientEndPointY', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'fillPatternRotation', 0);\nFactory_1.Factory.addGetterSetter(Shape, 'fillRule', undefined, (0, Validators_1.getStringValidator)());\nFactory_1.Factory.backCompat(Shape, {\n    dashArray: 'dash',\n    getDashArray: 'getDash',\n    setDashArray: 'getDash',\n    drawFunc: 'sceneFunc',\n    getDrawFunc: 'getSceneFunc',\n    setDrawFunc: 'setSceneFunc',\n    drawHitFunc: 'hitFunc',\n    getDrawHitFunc: 'getHitFunc',\n    setDrawHitFunc: 'setHitFunc',\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}