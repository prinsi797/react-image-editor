{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HitContext = exports.SceneContext = exports.Context = void 0;\n\nconst Util_1 = require(\"./Util\");\n\nconst Global_1 = require(\"./Global\");\n\nfunction simplifyArray(arr) {\n  var retArr = [],\n      len = arr.length,\n      util = Util_1.Util,\n      n,\n      val;\n\n  for (n = 0; n < len; n++) {\n    val = arr[n];\n\n    if (util._isNumber(val)) {\n      val = Math.round(val * 1000) / 1000;\n    } else if (!util._isString(val)) {\n      val = val + '';\n    }\n\n    retArr.push(val);\n  }\n\n  return retArr;\n}\n\nvar COMMA = ',',\n    OPEN_PAREN = '(',\n    CLOSE_PAREN = ')',\n    OPEN_PAREN_BRACKET = '([',\n    CLOSE_BRACKET_PAREN = '])',\n    SEMICOLON = ';',\n    DOUBLE_PAREN = '()',\n    EQUALS = '=',\n    CONTEXT_METHODS = ['arc', 'arcTo', 'beginPath', 'bezierCurveTo', 'clearRect', 'clip', 'closePath', 'createLinearGradient', 'createPattern', 'createRadialGradient', 'drawImage', 'ellipse', 'fill', 'fillText', 'getImageData', 'createImageData', 'lineTo', 'moveTo', 'putImageData', 'quadraticCurveTo', 'rect', 'roundRect', 'restore', 'rotate', 'save', 'scale', 'setLineDash', 'setTransform', 'stroke', 'strokeText', 'transform', 'translate'];\nvar CONTEXT_PROPERTIES = ['fillStyle', 'strokeStyle', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'letterSpacing', 'lineCap', 'lineDashOffset', 'lineJoin', 'lineWidth', 'miterLimit', 'direction', 'font', 'textAlign', 'textBaseline', 'globalAlpha', 'globalCompositeOperation', 'imageSmoothingEnabled'];\nconst traceArrMax = 100;\n\nclass Context {\n  constructor(canvas) {\n    this.canvas = canvas;\n\n    if (Global_1.Konva.enableTrace) {\n      this.traceArr = [];\n\n      this._enableTrace();\n    }\n  }\n\n  fillShape(shape) {\n    if (shape.fillEnabled()) {\n      this._fill(shape);\n    }\n  }\n\n  _fill(shape) {}\n\n  strokeShape(shape) {\n    if (shape.hasStroke()) {\n      this._stroke(shape);\n    }\n  }\n\n  _stroke(shape) {}\n\n  fillStrokeShape(shape) {\n    if (shape.attrs.fillAfterStrokeEnabled) {\n      this.strokeShape(shape);\n      this.fillShape(shape);\n    } else {\n      this.fillShape(shape);\n      this.strokeShape(shape);\n    }\n  }\n\n  getTrace(relaxed, rounded) {\n    var traceArr = this.traceArr,\n        len = traceArr.length,\n        str = '',\n        n,\n        trace,\n        method,\n        args;\n\n    for (n = 0; n < len; n++) {\n      trace = traceArr[n];\n      method = trace.method;\n\n      if (method) {\n        args = trace.args;\n        str += method;\n\n        if (relaxed) {\n          str += DOUBLE_PAREN;\n        } else {\n          if (Util_1.Util._isArray(args[0])) {\n            str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;\n          } else {\n            if (rounded) {\n              args = args.map(a => typeof a === 'number' ? Math.floor(a) : a);\n            }\n\n            str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;\n          }\n        }\n      } else {\n        str += trace.property;\n\n        if (!relaxed) {\n          str += EQUALS + trace.val;\n        }\n      }\n\n      str += SEMICOLON;\n    }\n\n    return str;\n  }\n\n  clearTrace() {\n    this.traceArr = [];\n  }\n\n  _trace(str) {\n    var traceArr = this.traceArr,\n        len;\n    traceArr.push(str);\n    len = traceArr.length;\n\n    if (len >= traceArrMax) {\n      traceArr.shift();\n    }\n  }\n\n  reset() {\n    var pixelRatio = this.getCanvas().getPixelRatio();\n    this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);\n  }\n\n  getCanvas() {\n    return this.canvas;\n  }\n\n  clear(bounds) {\n    var canvas = this.getCanvas();\n\n    if (bounds) {\n      this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);\n    } else {\n      this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);\n    }\n  }\n\n  _applyLineCap(shape) {\n    const lineCap = shape.attrs.lineCap;\n\n    if (lineCap) {\n      this.setAttr('lineCap', lineCap);\n    }\n  }\n\n  _applyOpacity(shape) {\n    var absOpacity = shape.getAbsoluteOpacity();\n\n    if (absOpacity !== 1) {\n      this.setAttr('globalAlpha', absOpacity);\n    }\n  }\n\n  _applyLineJoin(shape) {\n    const lineJoin = shape.attrs.lineJoin;\n\n    if (lineJoin) {\n      this.setAttr('lineJoin', lineJoin);\n    }\n  }\n\n  setAttr(attr, val) {\n    this._context[attr] = val;\n  }\n\n  arc(x, y, radius, startAngle, endAngle, counterClockwise) {\n    this._context.arc(x, y, radius, startAngle, endAngle, counterClockwise);\n  }\n\n  arcTo(x1, y1, x2, y2, radius) {\n    this._context.arcTo(x1, y1, x2, y2, radius);\n  }\n\n  beginPath() {\n    this._context.beginPath();\n  }\n\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n    this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n  }\n\n  clearRect(x, y, width, height) {\n    this._context.clearRect(x, y, width, height);\n  }\n\n  clip() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    this._context.clip.apply(this._context, args);\n  }\n\n  closePath() {\n    this._context.closePath();\n  }\n\n  createImageData(width, height) {\n    var a = arguments;\n\n    if (a.length === 2) {\n      return this._context.createImageData(width, height);\n    } else if (a.length === 1) {\n      return this._context.createImageData(width);\n    }\n  }\n\n  createLinearGradient(x0, y0, x1, y1) {\n    return this._context.createLinearGradient(x0, y0, x1, y1);\n  }\n\n  createPattern(image, repetition) {\n    return this._context.createPattern(image, repetition);\n  }\n\n  createRadialGradient(x0, y0, r0, x1, y1, r1) {\n    return this._context.createRadialGradient(x0, y0, r0, x1, y1, r1);\n  }\n\n  drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {\n    var a = arguments,\n        _context = this._context;\n\n    if (a.length === 3) {\n      _context.drawImage(image, sx, sy);\n    } else if (a.length === 5) {\n      _context.drawImage(image, sx, sy, sWidth, sHeight);\n    } else if (a.length === 9) {\n      _context.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n    }\n  }\n\n  ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise) {\n    this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise);\n  }\n\n  isPointInPath(x, y, path, fillRule) {\n    if (path) {\n      return this._context.isPointInPath(path, x, y, fillRule);\n    }\n\n    return this._context.isPointInPath(x, y, fillRule);\n  }\n\n  fill() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    this._context.fill.apply(this._context, args);\n  }\n\n  fillRect(x, y, width, height) {\n    this._context.fillRect(x, y, width, height);\n  }\n\n  strokeRect(x, y, width, height) {\n    this._context.strokeRect(x, y, width, height);\n  }\n\n  fillText(text, x, y, maxWidth) {\n    if (maxWidth) {\n      this._context.fillText(text, x, y, maxWidth);\n    } else {\n      this._context.fillText(text, x, y);\n    }\n  }\n\n  measureText(text) {\n    return this._context.measureText(text);\n  }\n\n  getImageData(sx, sy, sw, sh) {\n    return this._context.getImageData(sx, sy, sw, sh);\n  }\n\n  lineTo(x, y) {\n    this._context.lineTo(x, y);\n  }\n\n  moveTo(x, y) {\n    this._context.moveTo(x, y);\n  }\n\n  rect(x, y, width, height) {\n    this._context.rect(x, y, width, height);\n  }\n\n  roundRect(x, y, width, height, radii) {\n    this._context.roundRect(x, y, width, height, radii);\n  }\n\n  putImageData(imageData, dx, dy) {\n    this._context.putImageData(imageData, dx, dy);\n  }\n\n  quadraticCurveTo(cpx, cpy, x, y) {\n    this._context.quadraticCurveTo(cpx, cpy, x, y);\n  }\n\n  restore() {\n    this._context.restore();\n  }\n\n  rotate(angle) {\n    this._context.rotate(angle);\n  }\n\n  save() {\n    this._context.save();\n  }\n\n  scale(x, y) {\n    this._context.scale(x, y);\n  }\n\n  setLineDash(segments) {\n    if (this._context.setLineDash) {\n      this._context.setLineDash(segments);\n    } else if ('mozDash' in this._context) {\n      this._context['mozDash'] = segments;\n    } else if ('webkitLineDash' in this._context) {\n      this._context['webkitLineDash'] = segments;\n    }\n  }\n\n  getLineDash() {\n    return this._context.getLineDash();\n  }\n\n  setTransform(a, b, c, d, e, f) {\n    this._context.setTransform(a, b, c, d, e, f);\n  }\n\n  stroke(path2d) {\n    if (path2d) {\n      this._context.stroke(path2d);\n    } else {\n      this._context.stroke();\n    }\n  }\n\n  strokeText(text, x, y, maxWidth) {\n    this._context.strokeText(text, x, y, maxWidth);\n  }\n\n  transform(a, b, c, d, e, f) {\n    this._context.transform(a, b, c, d, e, f);\n  }\n\n  translate(x, y) {\n    this._context.translate(x, y);\n  }\n\n  _enableTrace() {\n    var that = this,\n        len = CONTEXT_METHODS.length,\n        origSetter = this.setAttr,\n        n,\n        args;\n\n    var func = function (methodName) {\n      var origMethod = that[methodName],\n          ret;\n\n      that[methodName] = function () {\n        args = simplifyArray(Array.prototype.slice.call(arguments, 0));\n        ret = origMethod.apply(that, arguments);\n\n        that._trace({\n          method: methodName,\n          args: args\n        });\n\n        return ret;\n      };\n    };\n\n    for (n = 0; n < len; n++) {\n      func(CONTEXT_METHODS[n]);\n    }\n\n    that.setAttr = function () {\n      origSetter.apply(that, arguments);\n      var prop = arguments[0];\n      var val = arguments[1];\n\n      if (prop === 'shadowOffsetX' || prop === 'shadowOffsetY' || prop === 'shadowBlur') {\n        val = val / this.canvas.getPixelRatio();\n      }\n\n      that._trace({\n        property: prop,\n        val: val\n      });\n    };\n  }\n\n  _applyGlobalCompositeOperation(node) {\n    const op = node.attrs.globalCompositeOperation;\n    var def = !op || op === 'source-over';\n\n    if (!def) {\n      this.setAttr('globalCompositeOperation', op);\n    }\n  }\n\n}\n\nexports.Context = Context;\nCONTEXT_PROPERTIES.forEach(function (prop) {\n  Object.defineProperty(Context.prototype, prop, {\n    get() {\n      return this._context[prop];\n    },\n\n    set(val) {\n      this._context[prop] = val;\n    }\n\n  });\n});\n\nclass SceneContext extends Context {\n  constructor(canvas) {\n    let {\n      willReadFrequently = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(canvas);\n    this._context = canvas._canvas.getContext('2d', {\n      willReadFrequently\n    });\n  }\n\n  _fillColor(shape) {\n    var fill = shape.fill();\n    this.setAttr('fillStyle', fill);\n\n    shape._fillFunc(this);\n  }\n\n  _fillPattern(shape) {\n    this.setAttr('fillStyle', shape._getFillPattern());\n\n    shape._fillFunc(this);\n  }\n\n  _fillLinearGradient(shape) {\n    var grd = shape._getLinearGradient();\n\n    if (grd) {\n      this.setAttr('fillStyle', grd);\n\n      shape._fillFunc(this);\n    }\n  }\n\n  _fillRadialGradient(shape) {\n    const grd = shape._getRadialGradient();\n\n    if (grd) {\n      this.setAttr('fillStyle', grd);\n\n      shape._fillFunc(this);\n    }\n  }\n\n  _fill(shape) {\n    const hasColor = shape.fill(),\n          fillPriority = shape.getFillPriority();\n\n    if (hasColor && fillPriority === 'color') {\n      this._fillColor(shape);\n\n      return;\n    }\n\n    const hasPattern = shape.getFillPatternImage();\n\n    if (hasPattern && fillPriority === 'pattern') {\n      this._fillPattern(shape);\n\n      return;\n    }\n\n    const hasLinearGradient = shape.getFillLinearGradientColorStops();\n\n    if (hasLinearGradient && fillPriority === 'linear-gradient') {\n      this._fillLinearGradient(shape);\n\n      return;\n    }\n\n    const hasRadialGradient = shape.getFillRadialGradientColorStops();\n\n    if (hasRadialGradient && fillPriority === 'radial-gradient') {\n      this._fillRadialGradient(shape);\n\n      return;\n    }\n\n    if (hasColor) {\n      this._fillColor(shape);\n    } else if (hasPattern) {\n      this._fillPattern(shape);\n    } else if (hasLinearGradient) {\n      this._fillLinearGradient(shape);\n    } else if (hasRadialGradient) {\n      this._fillRadialGradient(shape);\n    }\n  }\n\n  _strokeLinearGradient(shape) {\n    const start = shape.getStrokeLinearGradientStartPoint(),\n          end = shape.getStrokeLinearGradientEndPoint(),\n          colorStops = shape.getStrokeLinearGradientColorStops(),\n          grd = this.createLinearGradient(start.x, start.y, end.x, end.y);\n\n    if (colorStops) {\n      for (var n = 0; n < colorStops.length; n += 2) {\n        grd.addColorStop(colorStops[n], colorStops[n + 1]);\n      }\n\n      this.setAttr('strokeStyle', grd);\n    }\n  }\n\n  _stroke(shape) {\n    var dash = shape.dash(),\n        strokeScaleEnabled = shape.getStrokeScaleEnabled();\n\n    if (shape.hasStroke()) {\n      if (!strokeScaleEnabled) {\n        this.save();\n        var pixelRatio = this.getCanvas().getPixelRatio();\n        this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n      }\n\n      this._applyLineCap(shape);\n\n      if (dash && shape.dashEnabled()) {\n        this.setLineDash(dash);\n        this.setAttr('lineDashOffset', shape.dashOffset());\n      }\n\n      this.setAttr('lineWidth', shape.strokeWidth());\n\n      if (!shape.getShadowForStrokeEnabled()) {\n        this.setAttr('shadowColor', 'rgba(0,0,0,0)');\n      }\n\n      var hasLinearGradient = shape.getStrokeLinearGradientColorStops();\n\n      if (hasLinearGradient) {\n        this._strokeLinearGradient(shape);\n      } else {\n        this.setAttr('strokeStyle', shape.stroke());\n      }\n\n      shape._strokeFunc(this);\n\n      if (!strokeScaleEnabled) {\n        this.restore();\n      }\n    }\n  }\n\n  _applyShadow(shape) {\n    var _a, _b, _c;\n\n    var color = (_a = shape.getShadowRGBA()) !== null && _a !== void 0 ? _a : 'black',\n        blur = (_b = shape.getShadowBlur()) !== null && _b !== void 0 ? _b : 5,\n        offset = (_c = shape.getShadowOffset()) !== null && _c !== void 0 ? _c : {\n      x: 0,\n      y: 0\n    },\n        scale = shape.getAbsoluteScale(),\n        ratio = this.canvas.getPixelRatio(),\n        scaleX = scale.x * ratio,\n        scaleY = scale.y * ratio;\n    this.setAttr('shadowColor', color);\n    this.setAttr('shadowBlur', blur * Math.min(Math.abs(scaleX), Math.abs(scaleY)));\n    this.setAttr('shadowOffsetX', offset.x * scaleX);\n    this.setAttr('shadowOffsetY', offset.y * scaleY);\n  }\n\n}\n\nexports.SceneContext = SceneContext;\n\nclass HitContext extends Context {\n  constructor(canvas) {\n    super(canvas);\n    this._context = canvas._canvas.getContext('2d', {\n      willReadFrequently: true\n    });\n  }\n\n  _fill(shape) {\n    this.save();\n    this.setAttr('fillStyle', shape.colorKey);\n\n    shape._fillFuncHit(this);\n\n    this.restore();\n  }\n\n  strokeShape(shape) {\n    if (shape.hasHitStroke()) {\n      this._stroke(shape);\n    }\n  }\n\n  _stroke(shape) {\n    if (shape.hasHitStroke()) {\n      const strokeScaleEnabled = shape.getStrokeScaleEnabled();\n\n      if (!strokeScaleEnabled) {\n        this.save();\n        var pixelRatio = this.getCanvas().getPixelRatio();\n        this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n      }\n\n      this._applyLineCap(shape);\n\n      var hitStrokeWidth = shape.hitStrokeWidth();\n      var strokeWidth = hitStrokeWidth === 'auto' ? shape.strokeWidth() : hitStrokeWidth;\n      this.setAttr('lineWidth', strokeWidth);\n      this.setAttr('strokeStyle', shape.colorKey);\n\n      shape._strokeFuncHit(this);\n\n      if (!strokeScaleEnabled) {\n        this.restore();\n      }\n    }\n  }\n\n}\n\nexports.HitContext = HitContext;","map":{"version":3,"names":["Object","defineProperty","exports","value","HitContext","SceneContext","Context","Util_1","require","Global_1","simplifyArray","arr","retArr","len","length","util","Util","n","val","_isNumber","Math","round","_isString","push","COMMA","OPEN_PAREN","CLOSE_PAREN","OPEN_PAREN_BRACKET","CLOSE_BRACKET_PAREN","SEMICOLON","DOUBLE_PAREN","EQUALS","CONTEXT_METHODS","CONTEXT_PROPERTIES","traceArrMax","constructor","canvas","Konva","enableTrace","traceArr","_enableTrace","fillShape","shape","fillEnabled","_fill","strokeShape","hasStroke","_stroke","fillStrokeShape","attrs","fillAfterStrokeEnabled","getTrace","relaxed","rounded","str","trace","method","args","_isArray","join","map","a","floor","property","clearTrace","_trace","shift","reset","pixelRatio","getCanvas","getPixelRatio","setTransform","clear","bounds","clearRect","x","y","width","height","getWidth","getHeight","_applyLineCap","lineCap","setAttr","_applyOpacity","absOpacity","getAbsoluteOpacity","_applyLineJoin","lineJoin","attr","_context","arc","radius","startAngle","endAngle","counterClockwise","arcTo","x1","y1","x2","y2","beginPath","bezierCurveTo","cp1x","cp1y","cp2x","cp2y","clip","apply","closePath","createImageData","arguments","createLinearGradient","x0","y0","createPattern","image","repetition","createRadialGradient","r0","r1","drawImage","sx","sy","sWidth","sHeight","dx","dy","dWidth","dHeight","ellipse","radiusX","radiusY","rotation","counterclockwise","isPointInPath","path","fillRule","fill","fillRect","strokeRect","fillText","text","maxWidth","measureText","getImageData","sw","sh","lineTo","moveTo","rect","roundRect","radii","putImageData","imageData","quadraticCurveTo","cpx","cpy","restore","rotate","angle","save","scale","setLineDash","segments","getLineDash","b","c","d","e","f","stroke","path2d","strokeText","transform","translate","that","origSetter","func","methodName","origMethod","ret","Array","prototype","slice","call","prop","_applyGlobalCompositeOperation","node","op","globalCompositeOperation","def","forEach","get","set","willReadFrequently","_canvas","getContext","_fillColor","_fillFunc","_fillPattern","_getFillPattern","_fillLinearGradient","grd","_getLinearGradient","_fillRadialGradient","_getRadialGradient","hasColor","fillPriority","getFillPriority","hasPattern","getFillPatternImage","hasLinearGradient","getFillLinearGradientColorStops","hasRadialGradient","getFillRadialGradientColorStops","_strokeLinearGradient","start","getStrokeLinearGradientStartPoint","end","getStrokeLinearGradientEndPoint","colorStops","getStrokeLinearGradientColorStops","addColorStop","dash","strokeScaleEnabled","getStrokeScaleEnabled","dashEnabled","dashOffset","strokeWidth","getShadowForStrokeEnabled","_strokeFunc","_applyShadow","_a","_b","_c","color","getShadowRGBA","blur","getShadowBlur","offset","getShadowOffset","getAbsoluteScale","ratio","scaleX","scaleY","min","abs","colorKey","_fillFuncHit","hasHitStroke","hitStrokeWidth","_strokeFuncHit"],"sources":["D:/screenshort-extension/image-editor-react/node_modules/konva/lib/Context.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HitContext = exports.SceneContext = exports.Context = void 0;\nconst Util_1 = require(\"./Util\");\nconst Global_1 = require(\"./Global\");\nfunction simplifyArray(arr) {\n    var retArr = [], len = arr.length, util = Util_1.Util, n, val;\n    for (n = 0; n < len; n++) {\n        val = arr[n];\n        if (util._isNumber(val)) {\n            val = Math.round(val * 1000) / 1000;\n        }\n        else if (!util._isString(val)) {\n            val = val + '';\n        }\n        retArr.push(val);\n    }\n    return retArr;\n}\nvar COMMA = ',', OPEN_PAREN = '(', CLOSE_PAREN = ')', OPEN_PAREN_BRACKET = '([', CLOSE_BRACKET_PAREN = '])', SEMICOLON = ';', DOUBLE_PAREN = '()', EQUALS = '=', CONTEXT_METHODS = [\n    'arc',\n    'arcTo',\n    'beginPath',\n    'bezierCurveTo',\n    'clearRect',\n    'clip',\n    'closePath',\n    'createLinearGradient',\n    'createPattern',\n    'createRadialGradient',\n    'drawImage',\n    'ellipse',\n    'fill',\n    'fillText',\n    'getImageData',\n    'createImageData',\n    'lineTo',\n    'moveTo',\n    'putImageData',\n    'quadraticCurveTo',\n    'rect',\n    'roundRect',\n    'restore',\n    'rotate',\n    'save',\n    'scale',\n    'setLineDash',\n    'setTransform',\n    'stroke',\n    'strokeText',\n    'transform',\n    'translate',\n];\nvar CONTEXT_PROPERTIES = [\n    'fillStyle',\n    'strokeStyle',\n    'shadowColor',\n    'shadowBlur',\n    'shadowOffsetX',\n    'shadowOffsetY',\n    'letterSpacing',\n    'lineCap',\n    'lineDashOffset',\n    'lineJoin',\n    'lineWidth',\n    'miterLimit',\n    'direction',\n    'font',\n    'textAlign',\n    'textBaseline',\n    'globalAlpha',\n    'globalCompositeOperation',\n    'imageSmoothingEnabled',\n];\nconst traceArrMax = 100;\nclass Context {\n    constructor(canvas) {\n        this.canvas = canvas;\n        if (Global_1.Konva.enableTrace) {\n            this.traceArr = [];\n            this._enableTrace();\n        }\n    }\n    fillShape(shape) {\n        if (shape.fillEnabled()) {\n            this._fill(shape);\n        }\n    }\n    _fill(shape) {\n    }\n    strokeShape(shape) {\n        if (shape.hasStroke()) {\n            this._stroke(shape);\n        }\n    }\n    _stroke(shape) {\n    }\n    fillStrokeShape(shape) {\n        if (shape.attrs.fillAfterStrokeEnabled) {\n            this.strokeShape(shape);\n            this.fillShape(shape);\n        }\n        else {\n            this.fillShape(shape);\n            this.strokeShape(shape);\n        }\n    }\n    getTrace(relaxed, rounded) {\n        var traceArr = this.traceArr, len = traceArr.length, str = '', n, trace, method, args;\n        for (n = 0; n < len; n++) {\n            trace = traceArr[n];\n            method = trace.method;\n            if (method) {\n                args = trace.args;\n                str += method;\n                if (relaxed) {\n                    str += DOUBLE_PAREN;\n                }\n                else {\n                    if (Util_1.Util._isArray(args[0])) {\n                        str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;\n                    }\n                    else {\n                        if (rounded) {\n                            args = args.map((a) => typeof a === 'number' ? Math.floor(a) : a);\n                        }\n                        str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;\n                    }\n                }\n            }\n            else {\n                str += trace.property;\n                if (!relaxed) {\n                    str += EQUALS + trace.val;\n                }\n            }\n            str += SEMICOLON;\n        }\n        return str;\n    }\n    clearTrace() {\n        this.traceArr = [];\n    }\n    _trace(str) {\n        var traceArr = this.traceArr, len;\n        traceArr.push(str);\n        len = traceArr.length;\n        if (len >= traceArrMax) {\n            traceArr.shift();\n        }\n    }\n    reset() {\n        var pixelRatio = this.getCanvas().getPixelRatio();\n        this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);\n    }\n    getCanvas() {\n        return this.canvas;\n    }\n    clear(bounds) {\n        var canvas = this.getCanvas();\n        if (bounds) {\n            this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);\n        }\n        else {\n            this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);\n        }\n    }\n    _applyLineCap(shape) {\n        const lineCap = shape.attrs.lineCap;\n        if (lineCap) {\n            this.setAttr('lineCap', lineCap);\n        }\n    }\n    _applyOpacity(shape) {\n        var absOpacity = shape.getAbsoluteOpacity();\n        if (absOpacity !== 1) {\n            this.setAttr('globalAlpha', absOpacity);\n        }\n    }\n    _applyLineJoin(shape) {\n        const lineJoin = shape.attrs.lineJoin;\n        if (lineJoin) {\n            this.setAttr('lineJoin', lineJoin);\n        }\n    }\n    setAttr(attr, val) {\n        this._context[attr] = val;\n    }\n    arc(x, y, radius, startAngle, endAngle, counterClockwise) {\n        this._context.arc(x, y, radius, startAngle, endAngle, counterClockwise);\n    }\n    arcTo(x1, y1, x2, y2, radius) {\n        this._context.arcTo(x1, y1, x2, y2, radius);\n    }\n    beginPath() {\n        this._context.beginPath();\n    }\n    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n        this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    }\n    clearRect(x, y, width, height) {\n        this._context.clearRect(x, y, width, height);\n    }\n    clip(...args) {\n        this._context.clip.apply(this._context, args);\n    }\n    closePath() {\n        this._context.closePath();\n    }\n    createImageData(width, height) {\n        var a = arguments;\n        if (a.length === 2) {\n            return this._context.createImageData(width, height);\n        }\n        else if (a.length === 1) {\n            return this._context.createImageData(width);\n        }\n    }\n    createLinearGradient(x0, y0, x1, y1) {\n        return this._context.createLinearGradient(x0, y0, x1, y1);\n    }\n    createPattern(image, repetition) {\n        return this._context.createPattern(image, repetition);\n    }\n    createRadialGradient(x0, y0, r0, x1, y1, r1) {\n        return this._context.createRadialGradient(x0, y0, r0, x1, y1, r1);\n    }\n    drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {\n        var a = arguments, _context = this._context;\n        if (a.length === 3) {\n            _context.drawImage(image, sx, sy);\n        }\n        else if (a.length === 5) {\n            _context.drawImage(image, sx, sy, sWidth, sHeight);\n        }\n        else if (a.length === 9) {\n            _context.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n        }\n    }\n    ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise) {\n        this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise);\n    }\n    isPointInPath(x, y, path, fillRule) {\n        if (path) {\n            return this._context.isPointInPath(path, x, y, fillRule);\n        }\n        return this._context.isPointInPath(x, y, fillRule);\n    }\n    fill(...args) {\n        this._context.fill.apply(this._context, args);\n    }\n    fillRect(x, y, width, height) {\n        this._context.fillRect(x, y, width, height);\n    }\n    strokeRect(x, y, width, height) {\n        this._context.strokeRect(x, y, width, height);\n    }\n    fillText(text, x, y, maxWidth) {\n        if (maxWidth) {\n            this._context.fillText(text, x, y, maxWidth);\n        }\n        else {\n            this._context.fillText(text, x, y);\n        }\n    }\n    measureText(text) {\n        return this._context.measureText(text);\n    }\n    getImageData(sx, sy, sw, sh) {\n        return this._context.getImageData(sx, sy, sw, sh);\n    }\n    lineTo(x, y) {\n        this._context.lineTo(x, y);\n    }\n    moveTo(x, y) {\n        this._context.moveTo(x, y);\n    }\n    rect(x, y, width, height) {\n        this._context.rect(x, y, width, height);\n    }\n    roundRect(x, y, width, height, radii) {\n        this._context.roundRect(x, y, width, height, radii);\n    }\n    putImageData(imageData, dx, dy) {\n        this._context.putImageData(imageData, dx, dy);\n    }\n    quadraticCurveTo(cpx, cpy, x, y) {\n        this._context.quadraticCurveTo(cpx, cpy, x, y);\n    }\n    restore() {\n        this._context.restore();\n    }\n    rotate(angle) {\n        this._context.rotate(angle);\n    }\n    save() {\n        this._context.save();\n    }\n    scale(x, y) {\n        this._context.scale(x, y);\n    }\n    setLineDash(segments) {\n        if (this._context.setLineDash) {\n            this._context.setLineDash(segments);\n        }\n        else if ('mozDash' in this._context) {\n            this._context['mozDash'] = segments;\n        }\n        else if ('webkitLineDash' in this._context) {\n            this._context['webkitLineDash'] = segments;\n        }\n    }\n    getLineDash() {\n        return this._context.getLineDash();\n    }\n    setTransform(a, b, c, d, e, f) {\n        this._context.setTransform(a, b, c, d, e, f);\n    }\n    stroke(path2d) {\n        if (path2d) {\n            this._context.stroke(path2d);\n        }\n        else {\n            this._context.stroke();\n        }\n    }\n    strokeText(text, x, y, maxWidth) {\n        this._context.strokeText(text, x, y, maxWidth);\n    }\n    transform(a, b, c, d, e, f) {\n        this._context.transform(a, b, c, d, e, f);\n    }\n    translate(x, y) {\n        this._context.translate(x, y);\n    }\n    _enableTrace() {\n        var that = this, len = CONTEXT_METHODS.length, origSetter = this.setAttr, n, args;\n        var func = function (methodName) {\n            var origMethod = that[methodName], ret;\n            that[methodName] = function () {\n                args = simplifyArray(Array.prototype.slice.call(arguments, 0));\n                ret = origMethod.apply(that, arguments);\n                that._trace({\n                    method: methodName,\n                    args: args,\n                });\n                return ret;\n            };\n        };\n        for (n = 0; n < len; n++) {\n            func(CONTEXT_METHODS[n]);\n        }\n        that.setAttr = function () {\n            origSetter.apply(that, arguments);\n            var prop = arguments[0];\n            var val = arguments[1];\n            if (prop === 'shadowOffsetX' ||\n                prop === 'shadowOffsetY' ||\n                prop === 'shadowBlur') {\n                val = val / this.canvas.getPixelRatio();\n            }\n            that._trace({\n                property: prop,\n                val: val,\n            });\n        };\n    }\n    _applyGlobalCompositeOperation(node) {\n        const op = node.attrs.globalCompositeOperation;\n        var def = !op || op === 'source-over';\n        if (!def) {\n            this.setAttr('globalCompositeOperation', op);\n        }\n    }\n}\nexports.Context = Context;\nCONTEXT_PROPERTIES.forEach(function (prop) {\n    Object.defineProperty(Context.prototype, prop, {\n        get() {\n            return this._context[prop];\n        },\n        set(val) {\n            this._context[prop] = val;\n        },\n    });\n});\nclass SceneContext extends Context {\n    constructor(canvas, { willReadFrequently = false } = {}) {\n        super(canvas);\n        this._context = canvas._canvas.getContext('2d', {\n            willReadFrequently,\n        });\n    }\n    _fillColor(shape) {\n        var fill = shape.fill();\n        this.setAttr('fillStyle', fill);\n        shape._fillFunc(this);\n    }\n    _fillPattern(shape) {\n        this.setAttr('fillStyle', shape._getFillPattern());\n        shape._fillFunc(this);\n    }\n    _fillLinearGradient(shape) {\n        var grd = shape._getLinearGradient();\n        if (grd) {\n            this.setAttr('fillStyle', grd);\n            shape._fillFunc(this);\n        }\n    }\n    _fillRadialGradient(shape) {\n        const grd = shape._getRadialGradient();\n        if (grd) {\n            this.setAttr('fillStyle', grd);\n            shape._fillFunc(this);\n        }\n    }\n    _fill(shape) {\n        const hasColor = shape.fill(), fillPriority = shape.getFillPriority();\n        if (hasColor && fillPriority === 'color') {\n            this._fillColor(shape);\n            return;\n        }\n        const hasPattern = shape.getFillPatternImage();\n        if (hasPattern && fillPriority === 'pattern') {\n            this._fillPattern(shape);\n            return;\n        }\n        const hasLinearGradient = shape.getFillLinearGradientColorStops();\n        if (hasLinearGradient && fillPriority === 'linear-gradient') {\n            this._fillLinearGradient(shape);\n            return;\n        }\n        const hasRadialGradient = shape.getFillRadialGradientColorStops();\n        if (hasRadialGradient && fillPriority === 'radial-gradient') {\n            this._fillRadialGradient(shape);\n            return;\n        }\n        if (hasColor) {\n            this._fillColor(shape);\n        }\n        else if (hasPattern) {\n            this._fillPattern(shape);\n        }\n        else if (hasLinearGradient) {\n            this._fillLinearGradient(shape);\n        }\n        else if (hasRadialGradient) {\n            this._fillRadialGradient(shape);\n        }\n    }\n    _strokeLinearGradient(shape) {\n        const start = shape.getStrokeLinearGradientStartPoint(), end = shape.getStrokeLinearGradientEndPoint(), colorStops = shape.getStrokeLinearGradientColorStops(), grd = this.createLinearGradient(start.x, start.y, end.x, end.y);\n        if (colorStops) {\n            for (var n = 0; n < colorStops.length; n += 2) {\n                grd.addColorStop(colorStops[n], colorStops[n + 1]);\n            }\n            this.setAttr('strokeStyle', grd);\n        }\n    }\n    _stroke(shape) {\n        var dash = shape.dash(), strokeScaleEnabled = shape.getStrokeScaleEnabled();\n        if (shape.hasStroke()) {\n            if (!strokeScaleEnabled) {\n                this.save();\n                var pixelRatio = this.getCanvas().getPixelRatio();\n                this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n            }\n            this._applyLineCap(shape);\n            if (dash && shape.dashEnabled()) {\n                this.setLineDash(dash);\n                this.setAttr('lineDashOffset', shape.dashOffset());\n            }\n            this.setAttr('lineWidth', shape.strokeWidth());\n            if (!shape.getShadowForStrokeEnabled()) {\n                this.setAttr('shadowColor', 'rgba(0,0,0,0)');\n            }\n            var hasLinearGradient = shape.getStrokeLinearGradientColorStops();\n            if (hasLinearGradient) {\n                this._strokeLinearGradient(shape);\n            }\n            else {\n                this.setAttr('strokeStyle', shape.stroke());\n            }\n            shape._strokeFunc(this);\n            if (!strokeScaleEnabled) {\n                this.restore();\n            }\n        }\n    }\n    _applyShadow(shape) {\n        var _a, _b, _c;\n        var color = (_a = shape.getShadowRGBA()) !== null && _a !== void 0 ? _a : 'black', blur = (_b = shape.getShadowBlur()) !== null && _b !== void 0 ? _b : 5, offset = (_c = shape.getShadowOffset()) !== null && _c !== void 0 ? _c : {\n            x: 0,\n            y: 0,\n        }, scale = shape.getAbsoluteScale(), ratio = this.canvas.getPixelRatio(), scaleX = scale.x * ratio, scaleY = scale.y * ratio;\n        this.setAttr('shadowColor', color);\n        this.setAttr('shadowBlur', blur * Math.min(Math.abs(scaleX), Math.abs(scaleY)));\n        this.setAttr('shadowOffsetX', offset.x * scaleX);\n        this.setAttr('shadowOffsetY', offset.y * scaleY);\n    }\n}\nexports.SceneContext = SceneContext;\nclass HitContext extends Context {\n    constructor(canvas) {\n        super(canvas);\n        this._context = canvas._canvas.getContext('2d', {\n            willReadFrequently: true,\n        });\n    }\n    _fill(shape) {\n        this.save();\n        this.setAttr('fillStyle', shape.colorKey);\n        shape._fillFuncHit(this);\n        this.restore();\n    }\n    strokeShape(shape) {\n        if (shape.hasHitStroke()) {\n            this._stroke(shape);\n        }\n    }\n    _stroke(shape) {\n        if (shape.hasHitStroke()) {\n            const strokeScaleEnabled = shape.getStrokeScaleEnabled();\n            if (!strokeScaleEnabled) {\n                this.save();\n                var pixelRatio = this.getCanvas().getPixelRatio();\n                this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n            }\n            this._applyLineCap(shape);\n            var hitStrokeWidth = shape.hitStrokeWidth();\n            var strokeWidth = hitStrokeWidth === 'auto' ? shape.strokeWidth() : hitStrokeWidth;\n            this.setAttr('lineWidth', strokeWidth);\n            this.setAttr('strokeStyle', shape.colorKey);\n            shape._strokeFuncHit(this);\n            if (!strokeScaleEnabled) {\n                this.restore();\n            }\n        }\n    }\n}\nexports.HitContext = HitContext;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}